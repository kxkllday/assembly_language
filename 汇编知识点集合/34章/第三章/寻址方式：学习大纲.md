# 寻址方式：学习大纲

[toc]

> 1. 一共将介绍 7 种寻址方式，推荐的学习方式是在 DEBUG 工具中根据给出的例子亲手敲一遍
>
> 2. 各类的寻址方式会在后续学习中不断重复、加深，所以在学习这部分的时候不需要刻意进行训练，但是（1）要对使用不同寻址方式时出现的错误，和如何解决等进行记录（2）对新出现的寻址方式及时记录

---

> 注：DST 表示目标地址，SRC 表示源操作数，比如一个 MOV 指令就可以简写为 MOV DST, SRC；简言之，可以将源操作数看做数据，但是这个数据可以是直接取得的，也可以是间接的，可以是从寄存器取得的，也可以是从某个给定地址中取得的；学习寻址方式的核心目标，就是用不同方法将源操作数，也即数据，放入目标地址中



# 方法1：立即寻址方式

- 源操作数就是直接的数据，比如：

  > MOV AX, 5
  >
  > MOV BH, 100B
  >
  > MOV CX, 1000H
  >
  > MOV DX, 0FFFFH

- 可能出现的错误：

  - 立即数只能用在 SRC 部分

    > MOV 5, 5
    >
    > 以上的指令即使错误的

  - SRC 和 DST 的字长必须一致

    > MOV AH, 3064H
    >
    > 以上指令是错误的，因为 AH 指 AX 寄存器的高 8 位，而数据有 16 位

  - 如果使用十六进制的立即数，且第一个数字是 A~F，那么一定要在最前面加上一个 0

    > MOV AX, 10
    >
    > 以上的指令是将 10 放入寄存器 AX 中
    >
    > 但是如果将 10 转换为十六进制就会出现问题，因为这段指令将变为如下：
    >
    > MOV AX, AH
    >
    > 这里的 A 是十六进制的 10，而 H 代表十六进制；但是 AH 本身也指 AX 寄存器的高 8 位，这样就出现了歧义；所以正确的指令应该是：
    >
    > MOV AX, 0AH



# 方法2：寄存器寻址

- 源操作数放在指定的寄存器中，比如：

  > MOV AX, BX
  >
  > MOV AL, BH

- 可能出现的错误：

  - 可以在 SRC 部分使用的寄存器只有 AH, AL, AX, BH, BL, BX, CH, CL, CX, DH, DL, DX；如果使用了其它寄存器就会报错

  - SRC 和 DST 的字长应该一致

    > MOV AH, BX
    >
    > 以上的指令是错误的，因为 AH 为 8 位，而 BX 有 16 位

  - CS 不能用 MOV 指令改变

    > MOV CS, AX
    >
    > 以上指令是错误的



# 方法3：直接寻址方式

- 给定偏移地址，然后计算得到物理地址，再将物理地址指向的数据作为 SRC 或者将物理地址作为 DST，比如：

  > MOV AX, [2000H]
  >
  > MOV [1], BX

  注意，2000H 指的是偏移地址，而默认的基址地址存储在存储器 DS 中；假设 (DS)=3000H，根据物理地址计算公式，$3000H\times10+2000H=32000H$，所以以下指令：

  > MOV AX, [2000H]

  指的是，将从地址 32000H 开始的 16 位数据放入 AX 中

- 如果不想使用默认的存储器 DS，可以使用如下指令：

  > MOV AX, ES: [2000H]

  以上指令表示，改用 ES 中的数据作为基址地址进行物理地址的计算

- 因为给定的只是物理地址，所以具体数据要取多长的，就由 DST 来决定，比如 DST 是 AX，那么就是 16 为的数据



# 方法4：寄存器间接寻址

- 与直接寻址方式相似，只不过将偏移地址放入了寄存器中，比如：

  > MOV AX, [BX]
  >
  > MOV [BX], AX

  常用的用于存放偏移地址的寄存器有 BX, SI, DI 等

  默认的基址地址寄存器是 DS，当然同样可以修改，比如：

  > MOV AX, ES:[BX]

- 特别的，如果使用寄存器 BP 存放偏移地址，那么默认的存放基址地址的寄存器是 SS

- 可能出现的错误：
  - AX，CX，DX 不能存放偏移地址



# 方法5：寄存器相对寻址

- 通过一个例子即可理解：

  > MOV AX, COUNT[SI]，假设 (DS)=3000H, (SI)=2000H, COUNT=3000H
  >
  > 那么物理地址为，$3000H\times10+3000H+2000H=35000H$

- 可以使用的寄存器为 BX，BP，SI，DI



# 方法6：基址变址寻址方式

- 与寄存器间接寻址相似，不过偏移地址也可以进行计算，比如：

  > MOV AX, \[BX\][DI]
  >
  > MOV AX, [BX+DI]
  >
  > MOV AX, ES:\[BX\][SI]

  `MOV AX, [BX][DI]` 这条指令表示，偏移地址为寄存器 BX 和 DI 中存放的地址之和，物理地址计算方式不变

- 对于表示偏移地址的两个寄存器，其中一个是 BX 或 BP，另一个是 SI 或 DI

  > MOV AX, \[BX\][BP]
  >
  > 以上指令是错误的



# 方法7：相对基址变址寻址方式

- 同样类似，$偏移地址=\begin{cases}(BX)\\(BP)\end{cases}+\begin{cases}(SI)\\(DI)\end{cases}+\begin{cases}8位\\16位\end{cases}位移量$